<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Laberinto</title>

    <style>
    body {
      margin: 0;
      position: relative;
      height: 100vh;
    }
    canvas {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      border: 1px solid black;
    }
    </style>

</head>
<body>
    <canvas id="canvas"></canvas>

    <script>
    class Node {
      constructor(value) {
        this.value = value;
        this.next = null;
      }
    }
    
    class Queue {
      constructor() {
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
    
      enqueue(value) {
        const newNode = new Node(value);
        if (!this.tail) {
          this.head = this.tail = newNode;
        } else {
          this.tail.next = newNode; // "puntero" al siguiente nodo
          this.tail = newNode;
        }
        this.length++;
      }
    
      dequeue() {
        if (!this.head) return undefined;
        const value = this.head.value;
        this.head = this.head.next;
        if (!this.head) this.tail = null;
        this.length--;
        return value;
      }
    
      peek() {
        return this.head?.value;
      }
    
      isEmpty() {
        return this.length === 0;
      }
    
      size() {
        return this.length;
      }
    }
    
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const [rows, columns] = [21, 21]
    const resolution = 20
    canvas.width = columns * resolution
    canvas.height = rows * resolution
    const cellWidth = canvas.width/columns
    const cellHeight = canvas.height/rows

    let grid = [];

    for (let i = 0; i < rows; i++) {
        grid[i] = [];
        for (let j = 0; j < columns; j++) {
          if(i % 2 == 1 && j % 2 == 1) grid[i][j] = "#FFFFFF"
          else grid[i][j] = "#000000"
        }
    }

    function draw(){

        for(let i=0; i<rows; i++){
            for(let j=0; j<columns; j++){
                ctx.fillStyle = grid[i][j];
                ctx.fillRect(j*cellWidth, i*cellHeight, cellWidth, cellHeight);
            }
        }
        requestAnimationFrame(draw)
    }

    function getRandomPerimeterPoint() {
        const p = Math.floor(Math.random() * (2*columns + 2*rows))
        let x,y

        if (p < columns) {
            [x,y] = [p, 0];
        } else if (p < 2 * columns) {
            [x,y] = [p - columns, rows - 1];
        } else if (p < 2 * columns + rows) {
            [x,y] = [0, p - 2 * columns]; 
        } else {
            [x,y] = [columns - 1, p - 2 * columns - rows];
        }
        return [x,y]
    }

    function getRandomPoint(){
        let i = Math.floor(Math.random()*columns)
        let j = Math.floor(Math.random()*rows)
        return [i,j]
    }
    
    function getRandomStartingPoint(){
      let i = Math.floor(Math.random()*(columns-1)/2)*2 + 1
      let j = Math.floor(Math.random()*(rows-1)/2)*2 + 1
      return [i,j]
    }

    

    function getRandomColor() {
    	var letters = '0123456789ABCDEF';
    	var color = '#';
    	for (var i = 0; i < 6; i++) {
    	    color += letters[Math.floor(Math.random() * 16)];
    	}
    	return color;
    }
    
    function getKey(i, j) {
	    return `${i},${j}`;
    }
    
    const visitedGlobal = {}
    
    function test(p = getRandomPoint(), color){
      const q = new Queue()
      q.enqueue(p)
      function isValid(i, j) {
	      return !visitedGlobal[getKey(i,j)] && i >= 0 && i < rows && j >= 0 && j < columns && (grid[i][j] == "#000000");
	    }

	    function addPointBatch(batchSize = 1) {
    	  let count = 0;
    	  while (!q.isEmpty() && count < batchSize) {
          let [i,j] = q.dequeue()
          if(visitedGlobal[getKey(i,j)]) continue
          visitedGlobal[getKey(i,j)] = true
          grid[i][j] = color
          let a = Math.sign(i - p[0])
          let b = Math.sign(j - p[1])
          if (a === 0 && b === 0) {
      		  if (isValid(i, j - 1)) q.enqueue([i, j - 1]);
      		  if (isValid(i - 1, j)) q.enqueue([i - 1, j]);
      		  if (isValid(i, j + 1)) q.enqueue([i, j + 1]);
      		  if (isValid(i + 1, j)) q.enqueue([i + 1, j]);
	        }else if (a === 0) {
      		  if (isValid(i, j + b)) q.enqueue([i, j + b]);
      		  if (isValid(i + b, j)) q.enqueue([i + b, j]);
      		}else if (b === 0) {
      		  if (isValid(i + a, j)) q.enqueue([i + a, j]);
      		  if (isValid(i, j - a)) q.enqueue([i, j - a]);
      		}else if (a === b) {
      		  if (isValid(i + a, j)) q.enqueue([i + a, j]);
      		} else if (a !== b) {
      		  if (isValid(i, j + b)) q.enqueue([i, j + b]);
	        }
		      count++;
        }
        if (!q.isEmpty()) {
	        requestAnimationFrame(() => addPointBatch());
	      }
	    }
      addPointBatch()
    }
    
    function labyrinthAlg(startingPoint){
      const visited = {}
      
	    function getRandomNeighbour(p){
        function isValid(i,j){
          return !visited[getKey(i,j)] && (i >= 1) && (i < rows - 1) && (j >= 1) && (j < columns - 1)
        }
        const neighbours = []
        
        const i = p[0]
        const j = p[1]
        
        if (isValid(i, j - 2)) neighbours.push([i, j - 2])
        if (isValid(i - 2, j)) neighbours.push([i - 2, j])
        if (isValid(i, j + 2)) neighbours.push([i, j + 2])
        if (isValid(i + 2, j)) neighbours.push([i + 2, j])
        
        return neighbours.length > 0 ? neighbours[Math.floor(Math.random()*neighbours.length)] : [-1, -1]
        
      }
      
      visited[getKey(startingPoint[0],startingPoint[1])] = true
      const stack = []
      stack.push([startingPoint,0])
      grid[startingPoint[0]][startingPoint[1]] = '#00FF00'
      
      let iLast, jLast
      let lock = false
      let maxD = 0
      let currentFurthest = startingPoint
      let currentLast = startingPoint
      
      function start(){
        let count = 0
  	    while(stack.length != 0 && count < 1){
  	      let [current,d] = stack.pop()
  	      const [iNeighbourg, jNeighbourg] = getRandomNeighbour(current)
  	      if(iNeighbourg == -1){
  	        lock = true
  	        continue
  	      }
  	      stack.push([current,d])
  	      d++
  	      grid[(current[0] + iNeighbourg) / 2][(current[1] + jNeighbourg) / 2] = '#FFFFFF'
  	      visited[getKey(iNeighbourg,jNeighbourg)] = true
  	      stack.push([[iNeighbourg,jNeighbourg], d])
  	      grid[iNeighbourg][jNeighbourg] = '#0000FF'
  	      if((currentLast[0] != currentFurthest[0]) && (currentLast[1] != currentFurthest[1])){
  	        grid[currentLast[0]][currentLast[1]] = '#FFFFFF'
  	      
  	        console.log("aaa")
  	      }
  	      currentLast = [iNeighbourg, jNeighbourg]
  	      
  	      if(d > maxD){
  	        console.log(d)
  	        if(maxD > 0) grid[currentFurthest[0]][currentFurthest[1]] = '#FFFFFF'
  	        currentFurthest = [iNeighbourg, jNeighbourg]
  	        grid[currentFurthest[0]][currentFurthest[1]] = '#FF0000'
  	        maxD = d
  	      }
  	      count ++
  	      
  	    }

  	    if (stack.length != 0) {
  	      setTimeout(start, 10)
  	      //requestAnimationFrame(() => start());
  	    }
      }
      start()
    }
    
    
    canvas.addEventListener("click", (e) => {
    	const rect = canvas.getBoundingClientRect(); // posición y tamaño del canvas
  	  const i = Math.floor((event.clientY - rect.top)*rows/canvas.height)
  	  const j = Math.floor((event.clientX - rect.left)*columns/canvas.width);
    	test([i,j], getRandomColor())
    })
    requestAnimationFrame(draw)
    
    const p = getRandomStartingPoint()

    labyrinthAlg(p)

    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Laberinto</title>

    <style>
    body {
      margin: 0;
      position: relative;
      height: 100vh;
    }
    canvas {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      border: 1px solid black;
    }
    </style>

</head>
<body>
    <canvas id="canvas"></canvas>

    <script>
    class Node {
      constructor(value) {
        this.value = value;
        this.next = null;
      }
    }
    
    class Queue {
      constructor() {
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
    
      enqueue(value) {
        const newNode = new Node(value);
        if (!this.tail) {
          this.head = this.tail = newNode;
        } else {
          this.tail.next = newNode; // "puntero" al siguiente nodo
          this.tail = newNode;
        }
        this.length++;
      }
    
      dequeue() {
        if (!this.head) return undefined;
        const value = this.head.value;
        this.head = this.head.next;
        if (!this.head) this.tail = null;
        this.length--;
        return value;
      }
    
      peek() {
        return this.head?.value;
      }
    
      isEmpty() {
        return this.length === 0;
      }
    
      size() {
        return this.length;
      }
    }
        const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    canvas.width = 400
    canvas.height = 400

    const [rows, columns] = [100, 100]
    let grid = [];

    for (let i = 0; i < rows; i++) {
        grid[i] = [];
        for (let j = 0; j < columns; j++) {
            grid[i][j] = 0;
        }
    }

    function draw(){
        let cellWidth = canvas.width/columns
        let cellHeight = canvas.height/rows

        for(let i=0; i<columns; i++){
            for(let j=0; j<rows; j++){
                if(grid[i][j]){
                    ctx.fillStyle = "black";
                }else{
                    ctx.fillStyle = "white";
                }
                ctx.fillRect(j*cellWidth, i*cellHeight, cellWidth, cellHeight);
            }
        }
    }

    function getRandomPerimeterPoint() {
        const p = Math.floor(Math.random() * (2*columns + 2*rows))
        let x,y

        if (p < columns) {
            [x,y] = [p, 0];
        } else if (p < 2 * columns) {
            [x,y] = [p - columns, rows - 1];
        } else if (p < 2 * columns + rows) {
            [x,y] = [0, p - 2 * columns]; 
        } else {
            [x,y] = [columns - 1, p - 2 * columns - rows];
        }
        return [x,y]
    }

    function getRandomPoint(){
        let x = Math.floor(Math.random()*columns)
        let y = Math.floor(Math.random()*rows)
        return [x,y]
    }

    function test(){
        const q = new Queue()
        let p = getRandomPoint()
        q.enqueue(p)
    	const seen = {}
    	seen[p] = true
    	let r = Math.floor(Math.random()*13)
    	if(r%2 == 0) r++
        for(let n=0; n<r*r; n++){
              let [x,y] = q.dequeue()
	      grid[x][y] = 1
	      for(let i=-1; i<2; i++){
		for(let j=-1; j<2; j++){
		  if(!seen[[x+i,y+j]]){
		    q.enqueue([x+i,y+j])
		    seen[[x+i,y+j]] = true
		  }
		}
	      }
            
        }
    }

    setInterval(() => {
      test();
      draw()
    }, 100)
    
    
    test()
    draw()



    </script>
</body>
</html>
